---
title: "all country"
author: "Gregory Guranich"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{all country}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
knitr::opts_chunk$set(echo = TRUE)
library(FPEMcountry)
devtools::load_all()
library(ggplot2)
library(grid)
library(gridExtra)
```

## Table of Contents
1. [Introduction](#intro)
2. [Run models](#run)
3. [Plot model results](#plot)
  
## <a name="intro"></a>
## Introduction
In this vignette we will run two models for each country available, one for women in union and another for women not in union. We will use the package default data `fpemdata::contraceptive_use` for this example.
## Make directories for model files, import observed data and global model results
```{r}
divs <- divisions %>%
  dplyr::filter(name_region == "Africa") %>%
  dplyr::filter(division_numeric_code %in% contraceptive_use$division_numeric_code) %>% 
  dplyr::pull(division_numeric_code) %>%
  as.list()
```

## <a name="run"></a>
## run models
```{r}
first_year <- 1990
last_year <- 2010
fits <- purrr::pmap(list(division_numeric_code = divs, 
                         is_in_union = list("Y"), #may not need to list given the current data format, list seems to be a hack for data frames or other complex argument data types
                         first_year = list(first_year), 
                         last_year = list(last_year),
                         nchains = 3 %>% list,
                         niter = 500 %>% list,
                         nburnin = 100 %>% list
                         ), 
                    fpet_fit_model)
```

## Combine posterior samples from fits into one large array
Plucks the fits and corresponding posterior samples and combines each array of samples along index 1 making one large array. The first index of this large array corresponds to the country of the samples. Use dimnames() to see how to index a country. This is the identical format of an FPEMglobal run.
```{r}
combined_samples <- combine_samples_from_fits(fits, divs)
```


## <a name="Aggregation"></a>
## Aggregation 
To brainstrom: Should make another wrapper for first part of this section?
```{r}
## Get population data
population_data <- population_counts %>%
  dplyr::filter(is_in_union == "Y") %>%
  dplyr::filter(mid_year >= first_year) %>%
  dplyr::filter(mid_year <= last_year) %>%
  dplyr::filter(division_numeric_code %in% divs) %>% 
   dplyr::group_by(division_numeric_code, mid_year) %>%
   dplyr::top_n(1) %>% # years are doubled for some reason so this choses the correct ones
   dplyr::ungroup()

## Get divisions data
division_level_data <- divisions %>%
   dplyr::mutate(division_level = region_numeric_code)%>%
   dplyr::select(division_numeric_code, division_level) %>% 
   dplyr::filter(division_numeric_code %in% divs)

posterior_samples_list <- aggregate_samples(division_level_data, 
                                         population_data, 
                                         posterior_samples =  combined_samples)

```




## <a name="post-process"></a>
## Post-process, get point estimates from weighted samples
```{r}
## hack up a fit object similar to a one country fit 
fake_fit <- list()
fake_fit[["posterior_samples"]] <- posterior_samples_list[["903"]]
fake_fit$core_data$year_sequence_list$result_seq_years <- first_year
fake_fit_list <- list(fake_fit)
results_africa <- fpet_calculate_indicators(fake_fit_list,
                                            population_data)

```


