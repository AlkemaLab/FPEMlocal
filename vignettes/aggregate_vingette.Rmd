---
title: "national aggregate vignette"
author: "Niamh Cahill"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
fig_width: 10
vignette: >
  %\VignetteIndexEntry{aggregate vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(fig.width=10, fig.height=7) 
  library(fpemdata)
  library(fpemmodeling)
  library(fpemreporting)
  library(ggplot2)
  library(grid)
  library(gridExtra)
  library(rjags)
  library(R2jags)
```

## Table of Contents
1. [Introduction](#intro)
2. [Settings](#set)
3. [Run models](#run)
4. [Combine posterior samples arrays](#combine)
5. [Aggregation](#Aggregation)
6. [Post-process](#post-process)
7. [Plot](#plot)
  
## <a name="intro"></a>
## Introduction
In this vignette we will run the country specific model for women in union in the countries in Central Asia and aggregate the results. We will use the package default data `fpemdata::contraceptive_use` for this example. Alternatively, you can supply a survey file path to `fpemmodeling::do_1country_run` and run your own data. 

```{r, echo=FALSE}
options(warn=-1)
```

## <a name="set"></a>
## Choose countries to run
```{r}
## Example codes for countries in Central Asia: Kazakhstan, Kyrgyzstan, Tajikistan, Turkmenistan, Uzbekistan respectively	
codes <- c(398,417,762,795,860)
```

## <a name="run"></a>
## Run one-country, in-union model, for each country in Central Asia
```{r}
for(code in codes)
{
  post_samps <- fpemmodeling::do_1country_run(
    is_in_union = "Y",
    surveydata_filepath = NULL,
    division_numeric_code = code,
    first_year = 1989,
    last_year = 2030
  )$posterior_samples
  save(post_samps, file = paste0("post_samps_", code, ".rda"))
}
```

## <a name="post-process"></a>
## Combine posterior samples arrays into a single array
```{r}
## COMBINE RUNS
post_samps_combine <- fpemreporting::combine_runs(codes = codes)
```

## <a name="Aggregation"></a>
## Aggregation 
```{r}
## Get population data
population_data <- fpemdata::population_counts %>%
 dplyr::filter(is_in_union == "Y") %>%
   dplyr::filter(mid_year <= 2030) %>%
   dplyr::filter(mid_year >= 1989) %>% 
   dplyr::filter(division_numeric_code %in% codes) %>% 
   dplyr::group_by(division_numeric_code,mid_year) %>%
   dplyr::top_n(1) %>% # years are doubled for some reason so this choses the correct ones
   dplyr::ungroup()

## Get divisions data
division_level_data <- fpemdata::divisions %>%
   dplyr::mutate(division_level = region_numeric_code)%>%
   dplyr::select(division_numeric_code, division_level) %>% 
   dplyr::filter(division_numeric_code %in% codes)

## Create the array with the weigthed posterior samples i.e., aggregate
# undebug(weight_samples)
# # debug(fpemreporting:::weight_division_match)
# debug(weight_generator)
posterior_samples_list <- fpemreporting::weight_samples(division_level_data, 
                                         population_data, 
                                         posterior_samples =  post_samps_combine)
## Pull out the aggregate samples, in this case we aggregated for a sinlge region
samps_central_asia <- posterior_samples_list$`935`

```

## <a name="post-process"></a>
## Post-process, get point estimates from weighted samples
```{r}
## create results data 
results_central_asia <- fpemreporting::fpem_calculate_results(
  posterior_samples = samps_central_asia,
  first_year = 1989,
  country_population_counts = population_data)
```

## <a name="plot"></a>
## Plot results for aggregate
```{r,  echo=FALSE}

indicators <- fpemreporting:::indicator_names()
plots <- fpemreporting::fpem_plot_country_results(
  country_results = results_central_asia,
  first_year = 1989,
  last_year = 2030,
  is_in_union = "Y",
  indicators = indicators
  )
gridExtra::grid.arrange(grobs=plots[1:length(indicators)],
                 ncol=2,
                 top=textGrob("In-union women"))  
```

```{r}
#remove sample files created for this vignettes
file.remove(paste0("post_samps_", codes, ".rda"))
```
